# Claude Code 실전 활용 방법

# 1. 방대한 양의 코드를 확인 없이 수정

너무 방대한 양의 코드를 수정하면 코드가 실제로 어떻게 구성되어 가는지 트레킹이 불가능하여 점점 블랙박스 프로그램이 되어버리며 정상적인 작동을 보장할 수 없다.

**해결방법**

1. 계획을 먼저 수행하고 작은 테스크 별로 나눠서 수행한다. 각 테스크의 수정도 사람이 이해할 수 있는 정도의 수정을 단계적으로 수행한다.
2. 단계별로 코드 수정 내역을 확인한다. 이해가 되지 않는 부분은 질문하고 질의응답의 정보를 커멘트에 정보 형식으로 남긴다.
3. 작동 자체보다는 작성한 이유에 대한 논리적 내용이 담긴 커멘트를 생성한다. 특정한 가이드가 없다면 AI가 생성한 커멘트는 각 라인의 작동을 단순하게 설명하는 것으로 끝나는 경우가 많다.

**미래관점**

1. 만약 AI가 생성하는 코드에 버그가 없다면? ← 위 과정은 필요없어질 수 있다. 다만 AI가 이해하기 쉽도록 커멘트를 남기는 것은 의미가 있을것.
2. 이러한 단계에서는 의도한 대로 코딩이 작동이 되는가를 테스트 하는 과정이 더 중요할 것.

# 2. 부적절한 테스트 코드 작성

테스트를 작성하지 않는다던지 이해할 수 없는 테스트가 방대하게 작성되면 프로그램 유지 보수에 치명적일 수 있다. 특히 테스트의 수정은 해당 테스트가 수정이 되어야 하는가 아닌가에 대한 판단을 포함한 수정이기에 소스코드의 수정보다 더 어렵고 민감할 수 있다. 

**해결방법**

1. 테스트 도구와 시스템을 이해한 상태에서 사용한다. 테스트는 순수 코드로 수행하기 어려우며 다양한 테스트 프레임워크를 사용해야한다. 예를 들면 `pytest`, `playwright` 등이 그 예시가 될 수 있다.  테스트의 설정 방법은 유일하지 않고 그 안에 다양한 개념이 있기 때문에 충분히 이해가 될 때까지 질의응답해야 하며 그 결과를 커멘트로 남겨야 함.
2. 테스트 코드 작성에도 1의 원칙이 적용된다. 테스트는 작은 단계별로 작성되어야 하며, 각 테스트의 의미를 파악할 때까지 질의응답 시간이 필요하다. 그 결과는 함수의 커멘트에 작성되어야 한다.
3. 테스트 코드의 특성상 완전자동(불안정), 완전수동(효율저하) 둘 다 적절하지 않은 방향이다. 코딩 에이전트가 충분히 예측할만한 테스트 코드는 검토후 사용하고, 그 외의 specific한 테스트의 경우는 에이전트의 도움을 받아 정교하게 작성되어야 한다. 

**미래관점**

1. 테스트 도구 시스템에 대한 걱정을 안해도 되는 순간이 올 것이다. 다만 모든 경우의 수를 예측하여 테스트를 작성한는 것은 불가능 하기에, 특정 테스트 코드를 작성하라고 지시하는 일은 계속 유지될 것으로 생각된다. 하지만 자명한 테스트에 대한 자동화의 범위는 계속 확장될 것이다.

# 3. 긴 주기의 커밋

바이브 코딩을 하다보면 대량의 변경사항을 하나의 커밋에 수행하게 되는 경우가 발생한다. 물론 모든 변경사항을 파일별로 확인할 수 있고 커밋 메세지도 지능화 되어 대략적인 내용을 파악할 수 있지만 이러한 방식은 인간과 에이전트 모두 변경사항 추적과 복구를 어렵게 만든다. 

**해결방법**

1. 변경사항이 발생하면 새로운 브랜치를 생성하고 작성한다. 새로운 브랜치에서 1의 원칙을 지켜 코드를 작성하면 짧은 수정 주기마다 커밋이 가능하게 된다. 어떤 주기마다 수정을 적용해야 하는지는 경험적으로 직접 명령해도 되고 혹은 에이전트에게 조언을 구할 수도 있다. 극단적으로 짧은 수정, 긴 수정 둘 다 커밋에 부적절할 수 있기 때문이다. 하지만 대부분의 경우에 짧은 커밋이 더 나은 선택이다. 
2. 한 브랜치 내의 단일 커밋은 시스템의 완전한 작동을 보장하지 않을 수 있지만 하나의 브랜치가 머지되는 순간에는 해당 브랜치의 변경 사항이 시스템의 작동을 보장해야한다. 이는 에이전틱 코딩의 규칙이라기보단 일반적인 규칙이지만 이를 에이전트에게 가이드라인으로 제시하면 깃 워크플로우의 관리를 좀 더 명확하게 할 수 있다.

**미래관점**

1. 커밋 관리의 경우는 코스트도 작고 표준화가 충분히 가능하다고 생각한다. 따라서 직접적으로 신경쓰는 케이스는 줄어들고 간편한 지시만으로 충분히 버전관리 가능한 단계가 될 것으로 생각된다.
2. 특히 협업의 경우에서는 지금도 많은 도구들이 활용되고 있는 것으로 보인다. 
3. 나중에는 긴 주기의 커밋 내에서의 변경 사항을 분석해서 알아서 필요한 수정을 활용하는 방법까지 진화될 것으로 생각된다. 하지만 이는 불필요한 추가적인 코스트를 발생시키기에 가능은 하지만 권장되진 않을 것으로 예측된다.

# 4. 불안정한 개발 환경

대부분의 모던 프로그램은 메모장만으로는 개발하거나 배포할 수 없다. 강건한 소프트웨어 작성은 모든 코드 작성과 테스트 배포에 대한 전략이 사전에 준비되어야 원할하게 진행될 수 있다. 예를 들어 local terminal에서 개발을 할 것인지, 컨테이너 기반의 개발을 할 것인지 등의 결정을 해야한다. 각 결정에 따라 라이브러리 설치, 테스트 시스템 구축등도 영향을 받는다. 이러한 설정은 한 프로젝트의 기반이기 때문에 너무 많은 코드가 작성된 후에 적용하기에는 문제가 있을 수 있다 (항상 그러한 것은 아니다).

**해결방법** 

1. 모던 개발에 사용되는 개발 환경에 대한 이해가 필요하다. 에이전트가 제시하는 그대로 사용해도 작동이 될 수 있지만 이해가 되지 않는 모래 위에 집을 짓는것과 다를게 없는 일이다.
2. 1의 원칙이 역시 적용된다. 이해하지 못하는 부분은 질의응답을 통해 명료화 한 뒤 코드 안의 커멘트로 작성한다.

**미래관점**

1. 이 역시 일반적으로는 특별한 몇 케이스로 요약할 수 있기 때문에 한두번의 단순한 프롬프팅으로 완전 자동화 될 수 있는 영역이라 생각한다.

# 5. 부적절한 기술스택의 선택

 개발전 충분한 조사를 통하여 사용할 기술 스택을 결정해야 한다. 이는 개발 도구 (vite, uv) 라이브러리 (react, tailwindcss, zustant, …) 언어 (typescript, python) 등을 포함한다.

**해결방법**

1. 충분한 조사를 통하여 프로젝트 상황에 가장 적절한 기술스택으 결정한다. 이는 경험과 에이전트 리서치가 동반되야할 수 있다.
2. 스택의 결정과 이를 에이전트가 이해할 수 있는 형태로 정리하는 것은 프로젝트 전체에 영향을 준다. 생략해서는 안되며 주의깊게 작성해야 한다.

**미래관점**

1. 지금은 라이브러리에 대한 참조가 어느정도는 반자동의 느낌으로 작동하고 있지만, 추후 라이브러리와 에이전트의 통신등이 발전하면서 정말 어떤 라이브러리만 선택하면 좋을지 선택만 하면 되는 단계가 올 것이다.
2. 나중에는 적절한 기술스택의 선택 역시 자동화될 가능성이 크다.